# Лабораторная работа №4

## Описание

Создать динамические библиотеки, которые реализуют заданный вариантом функционал. Далее использовать данные библиотеки 2-мя способами:
1.	Во время компиляции (на этапе «линковки»/linking)
2.	Во время исполнения программы. Библиотеки загружаются в память с помощью интерфейса ОС для работы с динамическими библиотеками

## Заметки

Компиляция библиотеки:
- `gcc -shared -fPIC -o my_lib_1.so src/my_lib_1.c -lm`
- `gcc -shared -fPIC -o my_lib_2.so src/my_lib_2.c -lm`

Компиляция первой программы: 
- `gcc -o prog1 p1.c src/my_lib_1.c -lm`
- `gcc -o prog1 p1.c src/my_lib_2.c -lm`

Компиляция второй программы:
- `gcc p2.c -o prog2`

### mmap

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

Если передать в mmap первым аргументом NULL, то тогда мы позволим ядру выбирать адрес


## Анализ
В первой программе библиотека подключается через директиву #include, которая заменяется содержимым заголовочного файла. Дальше на этапе линковки связываются ссылки на функции с их определениями

Во второй программе, как видим из strace, библиотека загружается динамически (в рантайме):
```
openat(AT_FDCWD, "./my_lib_1.so", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
...
mmap(NULL, 16408, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7578b3704000
mmap(0x7578b3705000, 4096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1000) = 0x7578b3705000
mmap(0x7578b3706000, 4096, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7578b3706000
mmap(0x7578b3707000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7578b3707000
close(3)                                = 0
```
При закрытии:
```
munmap(0x7578b3704000, 16408)           = 0
```

При смене реализации:
```
openat(AT_FDCWD, "./my_lib_2.so", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
...
mmap(NULL, 16408, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7578b3704000
```

## Выводы

Из анализа видим:
- В первом случае есть гарантия на этапе компиляции, что в собранном бинарнике уже точно будет реализация библиотеки
- Во втором случае нет гарантии, что мы найдем реализацию библиотеки, но зато можно будет менять реализацию библиотеки в рантайме

Динамические библиотеки мощный инструмент, но с большой силой приходит большая ответственность. Очень полезно выносить часто используемые библиотеки в динамически подключаемые, чтобы экономить место на диске. Также они могут быть полезны для лёгкой подмены реализации без перекомпиляции основной программы.